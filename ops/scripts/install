#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  ./sereus/ops/scripts/install docker <service> [dest_dir]

Where:
  <service>  one of: relay | bootstrap | bootstrap-relay
  [dest_dir] optional path to create the site instance directory.
             If omitted, defaults to ./docker-<service> in the current directory.

What it does (idempotent, non-destructive):
  - creates <dest_dir> and <dest_dir>/data
  - copies env.example -> env.local (only if env.local does not exist)
  - links `svc` into <dest_dir> (only if missing)

Notes:
  - The instance directory can live anywhere (not necessarily under sereus-ops).
  - `svc` will locate the repo/compose automatically in common layouts.
    You can override with env vars:
      SEREUS_REPO_DIR=... ./svc up
EOF
}

die() {
  echo "ERROR: $*" >&2
  exit 1
}

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
repo_root="$(cd "$script_dir/../.." && pwd)"

docker_base=""
if [[ -d "$repo_root/ops/docker" ]]; then
  docker_base="$repo_root/ops/docker"
elif [[ -d "$repo_root/sereus/ops/docker" ]]; then
  docker_base="$repo_root/sereus/ops/docker"
else
  die "could not find ops/docker in repo; expected '$repo_root/ops/docker' or '$repo_root/sereus/ops/docker'"
fi

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  usage
  exit 0
fi

mode="${1:-}"
service="${2:-}"
dest="${3:-}"

[[ -n "$mode" && -n "$service" ]] || { usage; exit 2; }
[[ "$mode" == "docker" ]] || die "only 'docker' mode is scaffolded right now"

case "$service" in
  relay|bootstrap|bootstrap-relay) ;;
  *) die "unknown service: $service" ;;
esac

if [[ -z "$dest" ]]; then
  dest="$(pwd)/docker-$service"
fi

ref_dir="$docker_base/$service"
[[ -d "$ref_dir" ]] || die "reference folder not found: $ref_dir"

mkdir -p "$dest/data"

env_src="$ref_dir/env.example"
env_dst="$dest/env.local"
if [[ -f "$env_dst" ]]; then
  echo "env.local exists, leaving as-is: $env_dst"
else
  [[ -f "$env_src" ]] || die "env.example not found: $env_src"
  cp "$env_src" "$env_dst"
  chmod 600 "$env_dst" || true
  echo "created: $env_dst"

  # Make HOST_DATA_DIR unambiguous (absolute path on the host).
  # This avoids dependence on how docker-compose resolves relative paths.
  host_data_dir="$dest/data"
  tmpfile="$(mktemp)"
  awk -v v="$host_data_dir" '
    BEGIN { done=0 }
    /^HOST_DATA_DIR=/ {
      print "HOST_DATA_DIR=" v
      done=1
      next
    }
    { print }
    END {
      if (done==0) print "HOST_DATA_DIR=" v
    }
  ' "$env_dst" > "$tmpfile"
  mv "$tmpfile" "$env_dst"
fi

svc_src="$docker_base/site-scripts/svc.sh"
svc_dst="$dest/svc"
[[ -f "$svc_src" ]] || die "missing script: $svc_src"

if [[ -e "$svc_dst" ]]; then
  echo "exists, leaving as-is: $svc_dst"
else
  ln -s "$svc_src" "$svc_dst"
  echo "linked: $svc_dst -> $svc_src"
fi

# Convenience reference to the compose file (for humans). Note: build paths resolve relative
# to the compose file directory, so prefer using ./svc which points at the repo compose file.
compose_src="$ref_dir/docker-compose.yml"
compose_dst="$dest/compose.yml"
if [[ -f "$compose_src" ]]; then
  if [[ -e "$compose_dst" ]]; then
    echo "exists, leaving as-is: $compose_dst"
  else
    ln -s "$compose_src" "$compose_dst"
    echo "linked: $compose_dst -> $compose_src"
  fi
fi

cat <<EOF

Done.

Next:
  cd "$dest"
  edit ./env.local
  ./svc up
  ./svc logs

EOF


